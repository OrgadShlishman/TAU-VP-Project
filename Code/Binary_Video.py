import numpy as npimport cv2from tqdm import tqdmdef draw_starting_image():    image = np.ones((100, 600)) / 1.2    font = cv2.FONT_HERSHEY_SIMPLEX    text = 'Starting...'    cv2.putText(image, text, (150, 70), font, 2, (0, 255, 255), 2, cv2.LINE_4)    # Display the resulting frame    cv2.imshow('Binary percent', image)    cv2.waitKey(200)def draw_percent_image_binary(frame, n_frame):    image = np.ones((100, 600)) / 1.2    font = cv2.FONT_HERSHEY_SIMPLEX    text = 'frame ' + str(frame) + ' of ' + str(n_frame) + ' -- ' + str(int((frame / n_frame) * 100)) + '% Done'    cv2.putText(image, text, (50, 50), font, 1, (0, 255, 255), 2, cv2.LINE_4)    # Display the resulting frame    cv2.imshow('Binary percent', image)    cv2.waitKey(2)def background_histogram(cap):    """Calculate the Background Histogram based on the Median frame"""    n_frames = int(cap.get(cv2.CAP_PROP_FRAME_COUNT))    width = int(cap.get(cv2.CAP_PROP_FRAME_WIDTH))    height = int(cap.get(cv2.CAP_PROP_FRAME_HEIGHT))    # Choose randomly 50 frames and Calculate the median in time    frameIds = n_frames * np.random.uniform(size=50)    frames = []    for fid in frameIds:        cap.set(cv2.CAP_PROP_POS_FRAMES, fid)        ret, frame = cap.read()        frames.append(frame)    medianFrame = np.median(frames, axis=0).astype(dtype=np.uint8)    # Build 64 bin histogram (divide the image values by 4)    histogram = np.zeros((64, 64, 64))    medianFrame = medianFrame // 4    for i in range(0, height):        for j in range(0, width):            histogram[medianFrame[i, j, 0], medianFrame[i, j, 1], medianFrame[i, j, 2]] += 1    return histogramdef foreground_histogram(image, bw):    """Calculate the Foreground Histogram based on a Mask"""    # 64 Bin histogram    histogram = np.zeros((64, 64, 64))    for i in range(0, image.shape[0]):        for j in range(0, image.shape[1]):            if bw[i, j] == 255:                histogram[image[i, j, 0], image[i, j, 1], image[i, j, 2]] += 1    # normalize the histogram by the sum of the pixels    normalized_histogram = histogram / np.sum(histogram)    return normalized_histogramdef background_sub(input_name, binary_name, extracted_name, frameId = 91):    """Main function"""    print("Stage 2: Beckground Substruction")    # define the input and the output Videos    cap = cv2.VideoCapture(input_name)    n_frames = int(cap.get(cv2.CAP_PROP_FRAME_COUNT))    width = int(cap.get(cv2.CAP_PROP_FRAME_WIDTH))    height = int(cap.get(cv2.CAP_PROP_FRAME_HEIGHT))    fps = cap.get(cv2.CAP_PROP_FPS)    fourcc = cv2.VideoWriter_fourcc(*'XVID')    out = cv2.VideoWriter(binary_name, fourcc, fps, (width, height))    out2 = cv2.VideoWriter(extracted_name, fourcc, fps, (width, height))    # calculate the background histogram and normalize it + blurring    histogram_background = background_histogram(cap)    normalized_histogram_background = histogram_background / np.sum(histogram_background)    histogram_background = cv2.GaussianBlur(histogram_background, (3, 3), 0)    normalized_histogram_background = cv2.GaussianBlur(normalized_histogram_background, (3, 3), 0)    fg_prop = np.zeros((height // 2, width // 2))    bg_prop = np.zeros((height // 2, width // 2))    """ find the foreground histogram based on given frame frame """    # frameId = n_frames * np.random.uniform(size=1)    cap.set(cv2.CAP_PROP_POS_FRAMES, frameId)    ret, frame_org = cap.read()    # divide the frame by 4 due to 64 bin histogram    frame = frame_org // 4  # 64 bin    frame = cv2.resize(frame, (0, 0), fx=0.5, fy=0.5)  # to save time    for i in range(0, height // 2):        for j in range(0, width // 2):            bg_prop[i, j] = histogram_background[frame[i, j, 0], frame[i, j, 1], frame[i, j, 2]]    BW = 1 / (bg_prop + np.finfo(float).eps)    # find the foreground mask by finding the largest object at the BW 1/bf_prob    th, BW = cv2.threshold(BW, 0.08, 255, cv2.THRESH_BINARY)    BW = BW.astype(np.uint8)    kernel = cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (3, 3))    BW = cv2.erode(BW, kernel, iterations=2)    BW = cv2.dilate(BW, kernel, iterations=5)    nb_components, output, stats, centroids = cv2.connectedComponentsWithStats(BW, connectivity=8)    max_label, max_size = max([(i, stats[i, cv2.CC_STAT_AREA]) for i in range(1, nb_components)], key=lambda x: x[1])    bw_label = np.zeros((height // 2, width // 2))    bw_label[output == max_label] = 255    BW = cv2.erode(bw_label, kernel, iterations=2)    # find the foreground histogram based on the mask above and blur it.    normalized_histogram_foreground = foreground_histogram(frame, BW)    normalized_histogram_foreground = cv2.GaussianBlur(normalized_histogram_foreground, (3, 3), 0)    # after we calc the histograms we calc the Binary over all the video    cap.set(cv2.CAP_PROP_POS_FRAMES, 0)    i_f = 0    #while cap.isOpened():    for frame_n in tqdm(range(n_frames)):        #draw_percent_image_binary(i_f, n_frames)        i_f += 1        ret, frame_org = cap.read()        if (ret == False):            break        # divide by 4 due to 64 Bin histogram        frame = frame_org // 4  # 64 Bin        frame = cv2.resize(frame, (0, 0), fx=0.5, fy=0.5)        # calculate the probability map        for i in range(0, height // 2):            for j in range(0, width // 2):                fg_prop[i, j] = normalized_histogram_foreground[frame[i, j, 0], frame[i, j, 1], frame[i, j, 2]]                bg_prop[i, j] = normalized_histogram_background[frame[i, j, 0], frame[i, j, 1], frame[i, j, 2]]        BW = (fg_prop + np.finfo(float).eps) / (fg_prop + bg_prop + np.finfo(float).eps)        th, BW = cv2.threshold(BW, 0.7, 255, cv2.THRESH_BINARY)        BW = BW.astype(np.uint8)        kernel = cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (3, 3))        BW = cv2.erode(BW, kernel, iterations=2)        BW = cv2.dilate(BW, kernel, iterations=1)        BW = cv2.erode(BW, kernel, iterations=2)        # find the largest object        nb_components, output, stats, centroids = cv2.connectedComponentsWithStats(BW, connectivity=8)        max_label, max_size = max([(i, stats[i, cv2.CC_STAT_AREA]) for i in range(1, nb_components)],                                  key=lambda x: x[1])        bw_label = np.zeros((height // 2, width // 2))        bw_label[output == max_label] = 1        bw_label = cv2.dilate(bw_label, kernel, iterations=2)        bw_label = cv2.resize(bw_label, (0, 0), fx=2, fy=2)        # extracted the object from the frame        extract = np.zeros_like(frame_org)        extract[:, :, 0] = bw_label * frame_org[:, :, 0]        extract[:, :, 1] = bw_label * frame_org[:, :, 1]        extract[:, :, 2] = bw_label * frame_org[:, :, 2]        # save the Binary Video and Extracted        bw_label = (255 * bw_label).astype(np.uint8)        binary = cv2.cvtColor(bw_label, cv2.COLOR_GRAY2BGR)        out.write(binary)        out2.write(extract)    out.release()    out2.release()    cap.release()    cv2.destroyAllWindows()